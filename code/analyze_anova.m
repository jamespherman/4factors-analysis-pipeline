%% analyze_anova.m
%
% Performs a 4-way ANOVA on neuronal firing rates for the 4-factors task.
% This function uses a fixed 4-way interaction model with the factors:
% Saliency, Identity, Reward, and Probability.
%
% This function retrieves pre-computed categorical factors from the
% `conditions.factors` struct, which are generated by
% `define_task_conditions.m`. The specific factors to include in the
% model are determined by `anova_plan.factors`.
%
% The function dynamically builds the ANOVA model based on the provided
% factors and then filters the data to ensure that only trials with
% valid, non-empty labels for all factors are included.
%
% Inputs:
%   session_data - The main data struct for the session.
%   core_data    - The core data structure containing aligned neural data.
%   conditions   - A struct with logical masks for trial conditions and
%                  a 'factors' sub-struct containing pre-computed
%                  categorical variables for ANOVA.
%   anova_plan   - A struct defining the ANOVA parameters, including the
%                  alignment event, trial mask, and a list of factor
%                  names to test.
%
% Output:
%   session_data - The updated session_data struct with ANOVA results.
%
% Author: Jules
% Date: 2025-09-20
%

function session_data = analyze_anova(session_data, core_data, ...
    conditions, anova_plan)

    %% Setup Paths
    [script_dir, ~, ~] = fileparts(mfilename('fullpath'));
    addpath(fullfile(script_dir, 'utils'));

    %% Unpack ANOVA Parameters
    event_name = anova_plan.event;
    factors = anova_plan.factors;
    trial_mask_name = anova_plan.trial_mask;

    %% Initialize Results Structure
    if ~isfield(session_data, 'analysis')
        session_data.analysis = struct();
    end
    session_data.analysis.anova_results.(event_name) = struct();

    %% Prepare Data for ANOVA
    if ~isfield(core_data.spikes, event_name)
        warning('analyze_anova:eventNotFound', ...
            'Event ''%s'' not found in core_data. Skipping ANOVA.', ...
            event_name);
        return;
    end
    event_data = core_data.spikes.(event_name);
    time_vector = event_data.time_vector;

    % Calculate mean firing rate in the post-event window (t >= 0)
    post_event_bins = time_vector >= 0;
    mean_fr = mean(event_data.rates(:, :, post_event_bins), 3, 'omitnan');

    % Get the trial mask to select trials for the ANOVA
    if ~isfield(conditions, trial_mask_name)
        warning('analyze_anova:maskNotFound', ...
            'Trial mask ''%s'' not found in conditions. Skipping ANOVA.', ...
            trial_mask_name);
        return;
    end
    trial_mask = conditions.(trial_mask_name);
    filtered_fr = mean_fr(:, trial_mask);

    %% Prepare Factors for ANOVA
    % Retrieve pre-computed categorical factors from the conditions struct
    % based on the factor names defined in the anova_plan.
    factor_names_lower = anova_plan.factors;
    num_factors = length(factor_names_lower);
    group_vars = cell(1, num_factors);
    factor_names_capitalized = cell(1, num_factors);

    for i = 1:num_factors
        factor_name = factor_names_lower{i};
        % Check if the factor exists in the conditions struct
        if ~isfield(conditions.factors, factor_name)
            warning('analyze_anova:factorNotFound', ...
                'Factor ''%s'' not found in conditions.factors. Skipping ANOVA.', ...
                factor_name);
            return;
        end
        % Get the factor for all successful trials and filter by trial_mask
        factor_data = conditions.factors.(factor_name);
        group_vars{i} = factor_data(trial_mask);

        % Capitalize first letter for varnames used in anovan
        capitalized_name = [upper(factor_name(1)), factor_name(2:end)];
        factor_names_capitalized{i} = capitalized_name;
    end

    n_neurons = size(filtered_fr, 1);
    p_values = cell(1, n_neurons);
    term_names_collected = false;
    tbl_term_names = {};

    %% Create a master mask for valid trials
    % This ensures that only trials with complete data across all factors
    % are included in the ANOVA (i.e., no empty factor labels).
    num_trials_in_anova = sum(trial_mask);
    valid_trials_mask = true(num_trials_in_anova, 1);
    for i = 1:num_factors
        valid_trials_mask = valid_trials_mask & ~cellfun('isempty', group_vars{i});
    end

    % Filter all data by the valid trials mask
    fr_filt = filtered_fr(:, valid_trials_mask);
    for i = 1:num_factors
        group_vars{i} = group_vars{i}(valid_trials_mask);
    end

    % Check if there are enough trials to run the ANOVA
    if size(fr_filt, 2) < num_factors * 2
        warning('analyze_anova:notEnoughData', ...
            'Not enough valid trials to perform ANOVA. Skipping.');
        return;
    end

    % Prepare inputs for anovan
    % group_vars is already prepared. factor_names_capitalized is used
    % for the 'varnames' parameter.

    for i_neuron = 1:n_neurons
        y = fr_filt(i_neuron, :)';
        if sum(~isnan(y)) < length(y) * 0.5 || isempty(y)
            continue;
        end

        [p, tbl, ~, ~] = anovan(y, group_vars, 'model', 'interaction', ...
            'varnames', factor_names_capitalized, 'display', 'off');
        p_values{i_neuron} = p;

        if ~term_names_collected && ~isempty(tbl)
            tbl_term_names = tbl(2:(end-2), 1);
            term_names_collected = true;
        end
    end

    %% Store Results
    if term_names_collected
        for i_term = 1:length(tbl_term_names)
            field_name = matlab.lang.makeValidName(tbl_term_names{i_term});
            session_data.analysis.anova_results.(event_name).(field_name) = NaN(1, n_neurons);
        end

        for i_neuron = 1:n_neurons
            if ~isempty(p_values{i_neuron})
                for i_term = 1:length(tbl_term_names)
                    field_name = matlab.lang.makeValidName(tbl_term_names{i_term});
                    p_val = p_values{i_neuron}(i_term);
                    session_data.analysis.anova_results.(event_name).(field_name)(i_neuron) = p_val;
                end
            end
        end
    end
end
