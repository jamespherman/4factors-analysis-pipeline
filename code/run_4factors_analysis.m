%% run_4factors_analysis.m
%
% A robust, plan-driven orchestrator for the entire 4-factors analysis
% pipeline. This script iterates through a session manifest and executes a
% series of analyses as defined in the canonical analysis plan generated by
% define_task_conditions.m.
%
% Key Features:
% - Plan-Driven Execution: All analyses (Baseline Comparison, ROC, ANOVA,
%   etc.) are executed based on the provided analysis_plan struct.
% - Idempotency: The script performs comprehensive checks to determine if an
%   analysis has already been completed. For event-based analyses like
%   ANOVA, it ensures results exist for all required alignment events before
%   skipping, preventing partial re-runs.
% - Correct Data Structuring: Saves analysis results in the precise
%   nested structure required by the `aggregate_analysis_results.m` script,
%   ensuring seamless data aggregation.
%
% Author: Jules
% Date: 2025-09-23
%

%% Setup
clear; clc; close all;

% --- USER TOGGLES ---
force_rerun = struct(...
    'screening', false, ...
    'diag_pdfs', false, ...
    'dataprep',  false, ...
    'analyses',  false ...
);
% --- END USER TOGGLES ---

[script_dir, ~, ~] = fileparts(mfilename('fullpath'));
addpath(fullfile(script_dir, 'utils'));
project_root = fileparts(script_dir);

tic;
giveFeed = @(x)disp([num2str(round(toc, 1)) 's - ' x]);

%% Load Manifest
giveFeed('Loading session manifest...');
manifest_path = fullfile(project_root, 'config', 'session_manifest.csv');
if ~exist(manifest_path, 'file')
    error('run_4factors_analysis:manifestNotFound', ...
        'Session manifest not found at: %s', manifest_path);
end
manifest = readtable(manifest_path);
giveFeed('Manifest loaded.');

%% Load Analysis Plan
giveFeed('Loading analysis plan...');
% The single source of truth for the analysis plan is now
% define_task_conditions. We call it without arguments to get the plan.
[~, analysis_plan] = define_task_conditions();
giveFeed('Analysis plan loaded.');

%% Iterate Through Sessions
for i = 1:height(manifest)
    session_id = manifest.unique_id{i};
    giveFeed(sprintf('--- Starting processing for session: %s ---', ...
        session_id));

    % --- Read-Cache Logic: Prioritize Local Processed Data ---
    local_processed_dir = fullfile(project_root, 'data', 'processed', ...
        session_id);
    local_session_data_path = fullfile(local_processed_dir, ...
        [session_id, '_session_data.mat']);

    if exist(local_session_data_path, 'file')
        giveFeed(sprintf('Loading cached data for %s...', session_id));
        load(local_session_data_path, 'session_data');
        giveFeed('Cached data loaded.');
    else
        % If local file doesn't exist, load from OneDrive
        one_drive_path = findOneDrive;
        source_session_data_path = fullfile(one_drive_path, ...
            'Neuronal Data Analysis', session_id, [session_id ...
            '_session_data.mat']);

        if ~exist(source_session_data_path, 'file')
            warning('run_4factors_analysis:sessionDataNotFound', ...
                'session_data.mat not found for %s. Skipping.', ...
                session_id);
            continue;
        end

        giveFeed(sprintf('Loading source data for %s...', session_id));
        load(source_session_data_path, 'session_data');
        giveFeed('Source data loaded.');
    end

    % make sure we have all our metadata:
    session_data.metadata = table2struct(manifest(i,:));

    % assume that data has not been updated:
    data_updated = false;

    % --- On-Demand Metrics Calculation ---
    % If the session_data.metrics field is missing, compute it now. This
    % is a forward-compatibility step to ensure older data files can be
    % processed without manual intervention.
    if ~isfield(session_data, 'metrics')
        giveFeed('Metrics field not found. Calculating on-the-fly...');

        % --- Calculate Baseline Firing Rate ---
        % Retrieve config from the analysis plan
        config = analysis_plan.baseline_fr_config;

        % Create a trial mask for the specified task
        codes = initCodes();
        task_code_field = ['uniqueTaskCode_' config.task_name];
        if isfield(codes, task_code_field)
            task_code = codes.(task_code_field);
            trial_mask = session_data.trialInfo.taskCode == task_code;
        else
            error('run_4factors_analysis:taskCodeNotFound', ...
                  'Task code for "%s" not found in initCodes.', ...
                  config.task_name);
        end

        % Calculate baseline firing rate and store it
        baseline_fr = calculate_baseline_fr(session_data, ...
                                            config.event, ...
                                            config.window, ...
                                            trial_mask);
        session_data.metrics.baseline_frs = baseline_fr;

        % Calculate waveform metrics and add to session_data
        nClusters = height(session_data.spikes.cluster_info.cluster_id);
        for i_cluster = 1:nClusters

            % get current unit's multi-channel waveform:
            mean_waveform = session_data.spikes.wfMeans{i_cluster};

            % find channel with max variance:
            [~,max_var_chan] = max(var(mean_waveform,[],2));

            % Note: Assuming a sampling rate of 30000 Hz
            session_data.metrics.wf_metrics(i_cluster, 1) = ...
                calculate_waveform_metrics(mean_waveform(...
                max_var_chan,:), 30000);
        end

        % Mark the data as updated to ensure it gets saved
        data_updated = true;
        giveFeed('On-the-fly metrics calculation complete.');
    end

    % --- Define Task Conditions for this session ---
    giveFeed('Defining task conditions...');
    conditions = define_task_conditions(session_data);
    giveFeed('Task conditions defined.');

    % --- Dynamically discover all events from the analysis plan ---
    all_events = {};
    % 1. Add events from the top-level 'events' field, if it exists.
    if isfield(analysis_plan, 'events') && ~isempty(analysis_plan.events)
        all_events = [all_events, analysis_plan.events];
    end
    % 2. Discover events from sub-plans using the centralized field names.
    plan_fields = fieldnames(analysis_plan);
    event_field_names = analysis_plan.event_field_names;
    for i_field = 1:length(plan_fields)
        sub_plan_name = plan_fields{i_field};
        % Skip fields that are not analysis plans or already processed.
        if any(strcmp(sub_plan_name, {'events', 'event_field_names'}))
            continue;
        end

        sub_plan = analysis_plan.(sub_plan_name);
        if isstruct(sub_plan)
            for j = 1:length(sub_plan)
                for k = 1:length(event_field_names)
                    field_name = event_field_names{k};
                    if isfield(sub_plan(j), field_name) && ...
                       ~isempty(sub_plan(j).(field_name))
                        all_events{end+1} = sub_plan(j).(field_name);
                    end
                end
            end
        end
    end
    alignment_events = unique(all_events);
    event_proxy = '';
    if ~isempty(alignment_events)
        event_proxy = alignment_events{1};
    end

    % --- Dry run to calculate total number of steps for this session ---
    n_total_steps = 0;
    unique_id = session_id;
    if ~strcmp(manifest.screening_status{i}, 'complete') || ...
            force_rerun.screening
        n_total_steps = n_total_steps + 1;
    end
    diag_output_dir_dry_run = fullfile(project_root, 'figures', unique_id);
    if (~exist(diag_output_dir_dry_run, 'dir') || ...
            isempty(dir(fullfile(diag_output_dir_dry_run, '*.pdf'))))
        n_total_steps = n_total_steps + 1;
    end
    if ~strcmp(manifest.dataprep_status{i}, 'complete') || ...
            force_rerun.dataprep
        n_total_steps = n_total_steps + 1;
    end

    % --- Dry Run: Count Analysis Steps ---
    giveFeed('Dry run: calculating number of analysis steps...');

    % A. Baseline Comparison Analyses
    % An analysis is "complete" only if results exist for ALL events.
    for j = 1:length(analysis_plan.baseline_plan)
        plan_item = analysis_plan.baseline_plan(j);
        is_any_event_missing = false;
        % Check each event required by the master plan
        for k = 1:length(analysis_plan.events)
            event_name = analysis_plan.events{k};
            comp_name = plan_item.name;
            path_to_check = fullfile('analysis', 'baseline_comparison', ...
                event_name, comp_name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_any_event_missing = true;
                break; % Found a missing event, no need to check others
            end
        end

        if is_any_event_missing || force_rerun.analyses
            n_total_steps = n_total_steps + 1;
        end
    end

    % B. ROC Comparison Analyses
    for j = 1:length(analysis_plan.roc_plan)
        comp = analysis_plan.roc_plan(j);
        path_to_check = fullfile('analysis', 'roc_comparison', ...
            comp.event, comp.name);
        S = substruct_from_path(path_to_check);
        is_missing = false;
        try
            subsref(session_data, S);
        catch
            is_missing = true;
        end
        if is_missing || force_rerun.analyses
            n_total_steps = n_total_steps + 1;
        end
    end

    % C. N-way ANOVA Analysis
    if isfield(analysis_plan, 'anova_plan')
        for j = 1:length(analysis_plan.anova_plan)
            plan_item = analysis_plan.anova_plan(j);
            analysis_name = plan_item.name;
            is_any_event_missing = false;

            % Check each event required by the master plan
            for k = 1:length(analysis_plan.events)
                event_name = analysis_plan.events{k};
                path_to_check = fullfile('analysis', 'anova_results', ...
                    analysis_name, event_name);
                S = substruct_from_path(path_to_check);
                try
                    subsref(session_data, S);
                catch
                    is_any_event_missing = true;
                    break; % Found a missing event
                end
            end

            if is_any_event_missing || force_rerun.analyses
                n_total_steps = n_total_steps + 1;
            end
        end
    end

    % D. Behavioral Analyses
    % Loop through each behavioral analysis plan.
    if isfield(analysis_plan, 'behavior_plan')
        for j = 1:length(analysis_plan.behavior_plan)
            analysis_name = analysis_plan.behavior_plan(j).name;
            path_to_check = fullfile('analysis', 'behavioral_results', ...
                analysis_name);
            S = substruct_from_path(path_to_check);
            is_missing = false;
            try
                subsref(session_data, S);
            catch
                is_missing = true;
            end
            if is_missing || force_rerun.analyses
                n_total_steps = n_total_steps + 1;
            end
        end
    end

    % E. Population Decoding Analyses
    if isfield(analysis_plan, 'decoding_plan')
        % The execution has two potential steps, which are counted 
        % independently.

        % Stage 1: Count training step
        needs_training = force_rerun.analyses || ~isfield(session_data, ...
            'analysis') || ~isfield(session_data.analysis, ...
            'population_decoding');
        if needs_training
            n_total_steps = n_total_steps + 1;
        end

        % Stage 2: Count testing step
        is_any_test_missing = false;
        if isfield(session_data, 'analysis') && isfield(...
                session_data.analysis, 'population_decoding')
            testing_plan = analysis_plan.decoding_plan.testing_plan;
            for j = 1:length(testing_plan)
                test_name = testing_plan(j).test_name;
                if ~isfield(session_data.analysis.population_decoding, ...
                        test_name)
                    is_any_test_missing = true;
                    break;
                end
            end
        else
            % If the main struct is missing, tests are de facto missing.
            is_any_test_missing = true;
        end

        needs_testing = force_rerun.analyses || is_any_test_missing;
        if needs_testing
            % This step is counted independently of the training step. If
            % training is happening, the whole 'population_decoding' field
            % will be new, so testing will also need to run.
            n_total_steps = n_total_steps + 1;
        end
    end
    step_counter = 0;

    % --- Pipeline Stages ---
    % ... (screening, PDF gen, data prep stages are unchanged) ...
        % --- 1. Neuron Screening ---
    if ~strcmp(manifest.screening_status{i}, 'complete') || ...
        force_rerun.screening
        step_counter = step_counter + 1;
        fprintf(['\n--- Session %s: Starting Step %d of %d: ' ...
            '        Neuron Screening ---\n'], unique_id, ...
            step_counter, n_total_steps);
        giveFeed('Screening status is ''pending''. Running screening...');

        session_data.metadata.unique_id = session_id;
        if strcmp(session_data.metadata.brain_area, 'SNc')
            selected_neurons = screen_da_neurons(session_data, ...
                session_id, project_root);
        elseif strcmp(session_data.metadata.brain_area, 'SC')
            [selected_neurons, sig_epoch_comp, scSide] = ...
                screen_sc_neurons(session_data, project_root);
            session_data.analysis.scSide = scSide;
            session_data.analysis.sig_epoch_comparison = sig_epoch_comp;
        else
            warning('run_4factors_analysis:unknownSessionType', ...
                ['Unknown brain_area ''%s'' for session %s. Cannot ' ...
                'screen neurons.'], ...
                session_data.metadata.brain_area, session_id);
            continue;
        end

        session_data.analysis.selected_neurons = selected_neurons;

        data_updated = true; % Mark data as updated
        manifest.screening_status{i} = 'complete';
        giveFeed('Screening complete.');
    else
        giveFeed('Screening already complete. Loading results.');
        selected_neurons = session_data.analysis.selected_neurons;
    end

    % --- Per-Neuron Diagnostic PDF Generation ---
    giveFeed('Checking for per-neuron diagnostic PDFs...');
    diag_output_dir = fullfile(project_root, 'figures', session_id);

    % Check if the directory exists and contains any PDF files
    if (~exist(diag_output_dir, 'dir') || isempty(dir(fullfile( ...
            diag_output_dir, '*.pdf')))) || force_rerun.diag_pdfs
        step_counter = step_counter + 1;
        fprintf(['\n--- Session %s: Starting Step %d of %d: ' ...
            'Diagnostic PDF Generation ---\n'], unique_id, ...
            step_counter, n_total_steps);
        giveFeed('Generating diagnostic PDF...');
        if ~exist(diag_output_dir, 'dir')
            mkdir(diag_output_dir);
        end
        generate_neuron_summary_pdf(session_data, selected_neurons, ...
            session_id, diag_output_dir);
        giveFeed('Diagnostic PDF generation complete.');
    else
        giveFeed('Diagnostic PDF already exists, skipping...');
    end

    % --- 2. Core Data Preparation ---
    if ~strcmp(manifest.dataprep_status{i}, 'complete') || ...
        force_rerun.dataprep
        step_counter = step_counter + 1;
        fprintf(['\n--- Session %s: Starting Step %d of %d: ' ...
            'Core Data Preparation ---\n'], unique_id, ...
            step_counter, n_total_steps);
        giveFeed(['Data prep status is ''pending''. ' ...
            '            Running prepare_core_data...']);

        % --- Integration of Analysis Plan for Data Prep ---
        % The 'alignment_events' variable, calculated dynamically from the
        % analysis plan earlier in the script, is used here. This ensures
        % that the data preparation is always aligned with the full scope
        % of events required by all defined analyses.
        core_data = prepare_core_data(session_data, selected_neurons, ...
            alignment_events);
        session_data.analysis.core_data = core_data;

        data_updated = true; % Mark data as updated
        manifest.dataprep_status{i} = 'complete';
        giveFeed('Data prep complete.');
    else
        giveFeed('Data prep already complete. Loading core_data.');
        core_data = session_data.analysis.core_data;
    end

    % --- On-Demand Analysis Execution ---
    giveFeed('Checking for missing analyses...');

    % A. Baseline Comparison Analyses
    for j = 1:length(analysis_plan.baseline_plan)
        plan_item = analysis_plan.baseline_plan(j);
        comp_name = plan_item.name;
        is_any_event_missing = false;

        % Idempotency Check: Loop through all required events
        for k = 1:length(analysis_plan.events)
            event_name = analysis_plan.events{k};
            path_to_check = fullfile('analysis', 'baseline_comparison', ...
                event_name, comp_name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_any_event_missing = true;
                break;
            end
        end

        if is_any_event_missing || force_rerun.analyses
            step_counter = step_counter + 1;
            fprintf(['\n--- Session %s: Step %d/%d: Baseline ' ...
                'Comparison for %s ---\n'], unique_id, step_counter, ...
                n_total_steps, comp_name);
            giveFeed(sprintf('--> Running Baseline Comparison: %s', ...
                comp_name));

            % Call analyze_baseline_comparison once with all events
            result_by_event = analyze_baseline_comparison(core_data, ...
                conditions, plan_item, alignment_events);

            % Merge the results into the session_data struct
            event_names = fieldnames(result_by_event);
            for k = 1:length(event_names)
                event_name = event_names{k};
                if ~isfield(session_data.analysis, 'baseline_comparison')
                    session_data.analysis.baseline_comparison = struct();
                end
                session_data.analysis.baseline_comparison.(event_name).(comp_name) = ...
                    result_by_event.(event_name).(comp_name);
            end
            data_updated = true;
        end
    end

    % B. ROC Comparison Analyses
    for j = 1:length(analysis_plan.roc_plan)
        plan_item = analysis_plan.roc_plan(j);

        % Use substruct_from_path for a robust idempotency check.
        is_missing = false;
        path_to_check = fullfile('analysis', 'roc_comparison', ...
            plan_item.event, plan_item.name);
        S = substruct_from_path(path_to_check);
        try
            subsref(session_data, S);
        catch
            is_missing = true;
        end

        if is_missing || force_rerun.analyses
            step_counter = step_counter + 1;
            fprintf(['\n--- Session %s: Step %d/%d: ROC Comparison ' ...
                'for %s ---\n'], unique_id, step_counter, ...
                n_total_steps, plan_item.name);
            giveFeed(sprintf('--> Running ROC Comparison: %s', plan_item.name));

            result = analyze_roc_comparison(core_data, conditions, plan_item);
            session_data.analysis.roc_comparison.(plan_item.event).(...
                plan_item.name) = result;
            data_updated = true;
        end
    end

    % C. N-way ANOVA Analysis
    if isfield(analysis_plan, 'anova_plan')
        for j = 1:length(analysis_plan.anova_plan)
            plan_item = analysis_plan.anova_plan(j);
            analysis_name = plan_item.name;

            % Idempotency check: check all events
            is_any_event_missing = false;
            for k = 1:length(analysis_plan.events)
                event_name = analysis_plan.events{k};
                path_to_check = fullfile('analysis', 'anova_results', ...
                    analysis_name, event_name);
                S = substruct_from_path(path_to_check);
                try
                    subsref(session_data, S);
                catch
                    is_any_event_missing = true;
                    break;
                end
            end

            if is_any_event_missing || force_rerun.analyses
                step_counter = step_counter + 1;
                fprintf(['\n--- Session %s: Step %d/%d: N-way ANOVA ' ...
                    'for %s ---\n'], ...
                    unique_id, step_counter, n_total_steps, analysis_name);
                giveFeed(sprintf('--> Running N-way ANOVA: %s', ...
                    analysis_name));

                % Loop through each event and run the analysis
                for k = 1:length(alignment_events)
                    event_name = alignment_events{k};

                    % Create a temporary plan item with the event field
                    temp_plan_item = plan_item;
                    temp_plan_item.event = event_name;

                    % Pass the temporary plan item to the analysis function
                    session_data = analyze_anova(session_data, core_data, ...
                        conditions, temp_plan_item);
                end
                data_updated = true;
            end
        end
    end

    % D. Behavioral Analyses
    % Loop through each behavioral analysis plan.
    if isfield(analysis_plan, 'behavior_plan')
        for j = 1:length(analysis_plan.behavior_plan)
            plan_item = analysis_plan.behavior_plan(j);
            analysis_name = plan_item.name;

            % Use substruct_from_path for a robust idempotency check.
            is_missing = false;
            path_to_check = fullfile('analysis', ...
                'behavioral_results', analysis_name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_missing = true;
            end

            if is_missing || force_rerun.analyses
                step_counter = step_counter + 1;
                fprintf(['\n--- Session %s: Step %d/%d: Behavioral ' ...
                    'Analysis for %s ---\n'], unique_id, step_counter, ...
                    n_total_steps, analysis_name);
                giveFeed(sprintf('--> Running Behavioral Analysis: %s', ...
                    analysis_name));

                result = analyze_behavior(session_data, conditions, ...
                    plan_item);
                session_data.analysis.behavioral_results.(...
                    analysis_name) = result;
                data_updated = true;
            end
        end
    end

    % E. Population Decoding Analyses
    if isfield(analysis_plan, 'decoding_plan')
        % Idempotency check for the entire decoding suite. The suite is run
        % if any of its final test results are missing, ensuring that
        % transient trained models are always available for testing.
        run_decoding_suite = false;
        if force_rerun.analyses
            run_decoding_suite = true;
        else
            if ~isfield(session_data, 'analysis') || ~isfield(...
                    session_data.analysis, 'population_decoding')
                run_decoding_suite = true;
            else
                testing_plan = analysis_plan.decoding_plan.testing_plan;
                for j = 1:length(testing_plan)
                    test_name = testing_plan(j).test_name;
                    if ~isfield(...
                            session_data.analysis.population_decoding, ...
                            test_name)
                        run_decoding_suite = true;
                        break;
                    end
                end
            end
        end

        if run_decoding_suite
            % --- Stage 1: Train Models ---
            step_counter = step_counter + 1;
            fprintf(['\n--- Session %s: Step %d/%d: Population ' ...
                'Decoding: Model Training ---\n'], unique_id, ...
                step_counter, n_total_steps);
            giveFeed('--> Training all decoding models...');

            trained_models = {};
            training_plan = analysis_plan.decoding_plan.training_plan;
            for j = 1:length(training_plan)
                modelInfo = train_decoder(session_data, conditions, ...
                    core_data, training_plan(j));
                trained_models{end+1} = modelInfo;
            end
            giveFeed('--> Model training complete.');

            % --- Stage 2: Test Models ---
            step_counter = step_counter + 1;
            fprintf(['\n--- Session %s: Step %d/%d: Population ' ...
                'Decoding: Model Testing ---\n'], unique_id, ...
                step_counter, n_total_steps);
            giveFeed('--> Running decoding model tests...');

            testing_plan = analysis_plan.decoding_plan.testing_plan;
            for j = 1:length(testing_plan)
                testing_item = testing_plan(j);
                results = test_decoder(trained_models, conditions, ...
                    core_data, testing_item);
                session_data.analysis.population_decoding.(...
                    testing_item.test_name) = results;
                data_updated = true;
            end
            giveFeed('--> Model testing complete.');
        else
            giveFeed('--> Population decoding suite already complete.');
        end
    end

    % --- Save Updated Data ---
    if data_updated
        giveFeed('Data was updated, saving to local processed directory.');
        if ~exist(local_processed_dir, 'dir')
            mkdir(local_processed_dir);
        end
        save(local_session_data_path, 'session_data', '-v7.3');
        giveFeed('Save complete.');
    else
        giveFeed(['No new analyses or processing were required for ' ...
            '                this session.']);
    end

    % --- Verify Analysis Completion & Update Manifest ---
    giveFeed('Verifying analysis completion status...');
    is_analysis_complete = true;

    % A. Check baseline comparisons
    if is_analysis_complete
        for j = 1:length(analysis_plan.baseline_plan)
            plan_item = analysis_plan.baseline_plan(j);
            for k = 1:length(analysis_plan.events)
                event_name = analysis_plan.events{k};
                path_to_check = fullfile('analysis', 'baseline_comparison', ...
                    event_name, plan_item.name);
                S = substruct_from_path(path_to_check);
                try
                    subsref(session_data, S);
                catch
                    is_analysis_complete = false; break;
                end
            end
            if ~is_analysis_complete, break; end
        end
    end

    % B. Check ROC comparisons
    if is_analysis_complete
        for j = 1:length(analysis_plan.roc_plan)
            comp = analysis_plan.roc_plan(j);
            path_to_check = fullfile('analysis', 'roc_comparison', ...
                comp.event, comp.name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_analysis_complete = false; break;
            end
        end
    end

    % C. Check N-way ANOVA
    if is_analysis_complete && isfield(analysis_plan, 'anova_plan')
        for j = 1:length(analysis_plan.anova_plan)
            plan_item = analysis_plan.anova_plan(j);
            analysis_name = plan_item.name;
            for k = 1:length(analysis_plan.events)
                event_name = analysis_plan.events{k};
                path_to_check = fullfile('analysis', 'anova_results', ...
                    analysis_name, event_name);
                S = substruct_from_path(path_to_check);
                try
                    subsref(session_data, S);
                catch
                    is_analysis_complete = false;
                    break;
                end
            end
            if ~is_analysis_complete, break; end
        end
    end

    % D. Check behavioral analyses
    % Loop through each behavioral analysis plan to verify completion.
    if is_analysis_complete && isfield(analysis_plan, 'behavior_plan')
        for j = 1:length(analysis_plan.behavior_plan)
            analysis_name = analysis_plan.behavior_plan(j).name;
            path_to_check = fullfile('analysis', 'behavioral_results', ...
                analysis_name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_analysis_complete = false; break;
            end
        end
    end

    % E. Check population decoding results
    if is_analysis_complete && isfield(analysis_plan, 'decoding_plan')
        testing_plan = analysis_plan.decoding_plan.testing_plan;
        for j = 1:length(testing_plan)
            test_name = testing_plan(j).test_name;
            path_to_check = fullfile('analysis', 'population_decoding', ...
                test_name);
            S = substruct_from_path(path_to_check);
            try
                subsref(session_data, S);
            catch
                is_analysis_complete = false; break;
            end
        end
    end

    if is_analysis_complete
        manifest.analysis_status{i} = 'complete';
        giveFeed('All analyses for this session are complete.');
    else
        giveFeed('Some analyses for this session are still pending.');
    end

    giveFeed(sprintf('--- Finished processing for session: %s ---\n', ...
        session_id));
end

%% Finalize
giveFeed('All sessions processed. Saving updated manifest...');
writetable(manifest, manifest_path);
giveFeed('Manifest saved. Total time elapsed:');
toc
